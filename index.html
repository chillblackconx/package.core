<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Delivery City 3D - GPS</title>
<style>
body { margin:0; overflow:hidden; background:#87CEEB; }
#ui{
position:absolute;
top:10px;
left:10px;
color:white;
font-family:Arial;
background:rgba(0,0,0,0.6);
padding:10px;
border-radius:8px;
z-index:1;
}
#minimap{
position:absolute;
top:10px;
right:10px;
width:200px;
height:200px;
background:rgba(0,0,0,0.6);
border-radius:8px;
z-index:1;
}
</style>
</head>
<body>

<div id="ui">Score: 0</div>
<canvas id="minimap"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>

//////////////////////////////
// SCENE, CAMERA, RENDERER
//////////////////////////////
let scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);

let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

let light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(50,100,50);
scene.add(light);

//////////////////////////////
// SOL
//////////////////////////////
let ground = new THREE.Mesh(
  new THREE.PlaneGeometry(800,800), // carte plus grande
  new THREE.MeshLambertMaterial({color:0x3a3a3a})
);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

//////////////////////////////
// ROUTES
//////////////////////////////
for(let i=-400;i<=400;i+=20){
  let roadH = new THREE.Mesh(
    new THREE.BoxGeometry(800,0.1,8),
    new THREE.MeshLambertMaterial({color:0x222222})
  );
  roadH.position.z = i;
  scene.add(roadH);

  let roadV = new THREE.Mesh(
    new THREE.BoxGeometry(8,0.1,800),
    new THREE.MeshLambertMaterial({color:0x222222})
  );
  roadV.position.x = i;
  scene.add(roadV);
}

//////////////////////////////
// BÂTIMENTS
//////////////////////////////
const loader = new THREE.TextureLoader();
let wallTex = loader.load("build.normal.png");
let doorTex = loader.load("build.door.png");
let topTex  = loader.load("build.top.png");

wallTex.wrapS = THREE.RepeatWrapping;
wallTex.wrapT = THREE.RepeatWrapping;

for(let x=-380;x<=380;x+=40){
  for(let z=-380;z<=380;z+=40){
    if(Math.random()>0.3){
      let h = Math.random()*30+10;
      wallTex.repeat.set(1,h/20);

      let materials = [
        new THREE.MeshLambertMaterial({ map: wallTex }), // right
        new THREE.MeshLambertMaterial({ map: wallTex }), // left
        new THREE.MeshLambertMaterial({ map: topTex }),  // top
        new THREE.MeshLambertMaterial({ color:0x333333 }), // bottom
        new THREE.MeshLambertMaterial({ map: doorTex }), // front avec porte
        new THREE.MeshLambertMaterial({ map: wallTex })  // back
      ];

      let building = new THREE.Mesh(
        new THREE.BoxGeometry(20,h,20),
        materials
      );
      building.position.set(x,h/2,z);
      scene.add(building);
    }
  }
}

//////////////////////////////
// CAMIONNETTE
//////////////////////////////
const vanMaterials = [
  new THREE.MeshLambertMaterial({ map: loader.load("side.png") }),
  new THREE.MeshLambertMaterial({ map: loader.load("side.png") }),
  new THREE.MeshLambertMaterial({ map: loader.load("top.png") }),
  new THREE.MeshLambertMaterial({ color: 0x333333 }),
  new THREE.MeshLambertMaterial({ map: loader.load("front.png") }),
  new THREE.MeshLambertMaterial({ map: loader.load("back.png") })
];

let van = new THREE.Mesh(
  new THREE.BoxGeometry(4,2,8),
  vanMaterials
);
van.position.y = 1;
scene.add(van);

let velocity = 0;
let rotationSpeed = 0.03;

//////////////////////////////
// LIVRAISON
//////////////////////////////
let delivery = new THREE.Mesh(
  new THREE.CylinderGeometry(2,2,2,16),
  new THREE.MeshLambertMaterial({color:0x00ff00})
);
delivery.position.y = 1;
scene.add(delivery);

function newDelivery(){
  delivery.position.set(
    Math.random()*700-350,
    1,
    Math.random()*700-350
  );
}
newDelivery();

let score = 0;
let keys = {};

document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup", e => keys[e.key] = false);

//////////////////////////////
// MINI-MAP
//////////////////////////////
let minimap = document.getElementById("minimap");
let mmCtx = minimap.getContext("2d");

function updateMinimap(){
  mmCtx.clearRect(0,0,minimap.width,minimap.height);

  // fond
  mmCtx.fillStyle = "#222";
  mmCtx.fillRect(0,0,minimap.width,minimap.height);

  // conversion coordonnées jeu -> mini-map
  function toMap(v){
    let scale = minimap.width/800; // 800 = taille carte
    return {
      x: (v.x + 400) * scale,
      y: (v.z + 400) * scale
    };
  }

  // livraison
  let dPos = toMap(delivery.position);
  mmCtx.fillStyle = "green";
  mmCtx.beginPath();
  mmCtx.arc(dPos.x, dPos.y, 5,0,2*Math.PI);
  mmCtx.fill();

  // camionnette
  let vPos = toMap(van.position);
  mmCtx.fillStyle = "red";
  mmCtx.beginPath();
  mmCtx.arc(vPos.x, vPos.y, 5,0,2*Math.PI);
  mmCtx.fill();
}

//////////////////////////////
// UPDATE / ANIMATE
//////////////////////////////
function update(){
  if(keys["ArrowUp"]) velocity += 0.01;
  if(keys["ArrowDown"]) velocity -= 0.01;
  velocity *= 0.98;

  if(keys["ArrowLeft"]) van.rotation.y += rotationSpeed;
  if(keys["ArrowRight"]) van.rotation.y -= rotationSpeed;

  van.position.x -= Math.sin(van.rotation.y) * velocity;
  van.position.z -= Math.cos(van.rotation.y) * velocity;

  if(van.position.distanceTo(delivery.position) < 5){
    score++;
    document.getElementById("ui").innerHTML = "Score: " + score;
    newDelivery();
  }

  let cameraOffset = new THREE.Vector3(0,6,15);
  cameraOffset.applyAxisAngle(new THREE.Vector3(0,1,0), van.rotation.y);
  camera.position.copy(van.position).add(cameraOffset);
  camera.lookAt(van.position);

  updateMinimap();
  renderer.render(scene,camera);
}

function animate(){
  requestAnimationFrame(animate);
  update();
}
animate();

//////////////////////////////
// RESIZE
//////////////////////////////
window.addEventListener("resize",()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

</script>
</body>
</html>
